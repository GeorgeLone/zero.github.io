<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> unity中对spine动画图集的动态加载 · 自我折磨症患者</title><meta name="description" content="unity中对spine动画图集的动态加载 - Zero Joe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://nobidagu.github.io/atom.xml" title="自我折磨症患者"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">自我折磨症患者</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/about" target="_self" class="li component-nav-item"><p>关于</p></a><ul class="shortcut-icons"></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">unity中对spine动画图集的动态加载</h1><div class="post-info">Sep 21, 2017</div><div class="post-content"><hr>
<p>项目采用spine作为角色的动画文件,但是主角的动画文件越做越大,而unity导入spine的动画又是预加载全部图集,<br>所以研究了下spine图集的的动态加载,简单的改了一下spine的unity库,可以实现图集的动态加载.</p>
<hr>
<a id="more"></a>
<p>首先你要为你的图集分好类,比如序列帧/同一套皮肤 等等,尽量打包到同一张图集里面,交叉引用可不是个好的做法.<br>然后打出动画文件,在unity中reimport后会生成几个文件 <br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr0z8bkoej208503mwen.jpg" alt="img"> <br><br>材质上引用的图片纹理 <br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr11mtvaij209j054q31.jpg" alt="img"><br></p>
<p>由于unity默认会把材质上关联的纹理加载到内存中,所以在生成材质后,我们需要把材质引用的图片置为null,然后在游戏中动态的载入需要的图集. <br><br>Ps: 记得把所有材质关联的图片纹理都置为null哦.<br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr15cqlhmj209r040wei.jpg" alt="img"> <br></p>
<hr>
<p>因为spine动画载入后直接是引用的动画asset上的材质,如果我们直接修改后会导致配置文件上的材质也会应用此修改;因此我们需要运行时自己动态创建材质,外部修改运行时创建的材质.<br><br>在这里我为引用列表加入了一个变量来控制是否需要动态材质,因为可能只有少数的图片量很大动画需要运行时加载图集.<br></p>
<p>修改spine-unity中的AtlasAsset.cs文件,加入这个.<br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1e5og2oj20el02sdg2.jpg" alt="img"> <br><br>相应的AtlasAssetInspector也要加入.<br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1foj3bnj20bw01gq31.jpg" alt="img"> <br><br>现在引用列表文件上就会有一个选项了,我们要用它来决定是否需要动态创建材质以用于修改. <br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1i1babjj209a06gglq.jpg" alt="img"> <br></p>
<hr>
<p>接下来修改AtlasAsset.cs文件中的MaterialsTextureLoader中的load函数.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Load</span> (<span class="params">AtlasPage page, String path</span>) </span>&#123;</div><div class="line">    String name = Path.GetFileNameWithoutExtension(path);</div><div class="line">    Material material = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (atlasAsset.dynamicMats) <span class="comment">// 动态创建材质</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">foreach</span> (Material other <span class="keyword">in</span> atlasAsset.materials) &#123;</div><div class="line">            <span class="keyword">if</span> (other.name.Split(<span class="string">'_'</span>)[<span class="number">1</span>] == name) &#123; <span class="comment">// 这里要改一下,因为没有默认纹理了,需要用材质本身的名字来匹配</span></div><div class="line">                material = other;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</div><div class="line">            Debug.LogError(<span class="string">"Material with texture name \""</span> + name + <span class="string">"\" not found for atlas asset: "</span> + atlasAsset.name, atlasAsset);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        page.rendererObject = <span class="keyword">new</span> Material(material); <span class="comment">// 新建材质</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">foreach</span> (Material other <span class="keyword">in</span> atlasAsset.materials) &#123;</div><div class="line">            <span class="keyword">if</span> (other.mainTexture == <span class="literal">null</span>) &#123;</div><div class="line">                Debug.LogError(<span class="string">"Material is missing texture: "</span> + other.name, other);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (other.mainTexture.name == name) &#123;</div><div class="line">                material = other;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</div><div class="line">            Debug.LogError(<span class="string">"Material with texture name \""</span> + name + <span class="string">"\" not found for atlas asset: "</span> + atlasAsset.name, atlasAsset);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        page.rendererObject = material;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Very old atlas files expected the texture's actual size to be used at runtime.</span></div><div class="line">    <span class="keyword">if</span> (page.width == <span class="number">0</span> || page.height == <span class="number">0</span>) &#123;</div><div class="line">        page.width = material.mainTexture.width;</div><div class="line">        page.height = material.mainTexture.height;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为考虑到载入图集的频率不会很频繁,所以呢,我把Atlas上的rendererobject用这种方式提供了出来.<br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1pgvgczj20kb02gdg0.jpg" alt="img"> <br></p>
<p>然后就可以用这种方式在运行时修改纹理了.<br><br>Ps: 记得调用完后用 Resource.UnloadUnUsedAsset()来卸载内存. <br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1trfe7ij20bw01vjrh.jpg" alt="img"> <br></p>
<p>然后内存占用就会从这样 <br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1wtv9mrj20da03e3yi.jpg" alt="img"> <br><br>变成这样了. <br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1ydn35cj20di04aaa7.jpg" alt="img"> <br><br>此例子中我只使用到了body图集,技能特效就全部不加载了,你可以用上面的方式,在需要的时候把图集载入进来关联到相应的材质上.<br></p>
<p>谢谢观赏!!!</p>
</div></article></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'nobidagu';
var disqus_identifier = '2017/09/21/unity中对spine动画图集的动态加载/';
var disqus_title = 'unity中对spine动画图集的动态加载';
var disqus_url = 'https://nobidagu.github.io/2017/09/21/unity中对spine动画图集的动态加载/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//nobidagu.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/2018/12/15/句子/" class="prev">上一篇</a><a href="/2017/09/10/画画练习/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2018 <a href="https://nobidagu.github.io">Zero Joe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"angrypowman",'auto');ga('send','pageview');</script></body></html>