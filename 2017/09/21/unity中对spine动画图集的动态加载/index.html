<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>unity中对spine动画图集的动态加载 | Hexo</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">Hexo</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">主页|Home</a><a href="/archives" class="sidebar-nav-item">归档|Archives</a><a href="/about" class="sidebar-nav-item">关于|About</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>unity中对spine动画图集的动态加载</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2017-09-21</div></div></div><article><div class="container post"><hr>
<p>项目采用spine作为角色的动画文件,但是主角的动画文件越做月越大,而unity导入spine的动画又是预加载全部图集,<br>所以研究了下spine图集的的动态加载,简单的改了一下spine的unity库,可以实现图集的动态加载.</p>
<hr>
<p>首先你要为你的图集分好类,比如序列帧/同一套皮肤 等等,尽量打包到同一张图集里面,交叉引用可不是个好的做法.<br>然后打出动画文件,在unity中reimport后会生成几个文件 <br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr0z8bkoej208503mwen.jpg" alt="img"> <br><br>材质上引用的图片纹理 <br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr11mtvaij209j054q31.jpg" alt="img"><br></p>
<p>由于unity默认会把材质上关联的纹理加载到内存中,所以在生成材质后,我们需要把材质引用的图片置为null,然后在游戏中动态的载入需要的图集. <br><br>Ps: 记得把所有材质关联的图片纹理都置为null哦.<br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr15cqlhmj209r040wei.jpg" alt="img"> <br></p>
<hr>
<p>因为spine动画载入后直接是引用的动画asset上的材质,如果我们直接修改后会导致配置文件上的材质也会应用此修改;因此我们需要运行时自己动态创建材质,外部修改运行时创建的材质.<br><br>在这里我为引用列表加入了一个变量来控制是否需要动态材质,因为可能只有少数的图片量很大动画需要运行时加载图集.<br></p>
<p>修改spine-unity中的AtlasAsset.cs文件,加入这个.<br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1e5og2oj20el02sdg2.jpg" alt="img"> <br><br>相应的AtlasAssetInspector也要加入.<br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1foj3bnj20bw01gq31.jpg" alt="img"> <br><br>现在引用列表文件上就会有一个选项了,我们要用它来决定是否需要动态创建材质以用于修改. <br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1i1babjj209a06gglq.jpg" alt="img"> <br></p>
<hr>
<p>接下来就修改AtlasAsset.cs文件中的MaterialsTextureLoader中的load函数.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Load</span> (<span class="params">AtlasPage page, String path</span>) </span>&#123;</div><div class="line">    String name = Path.GetFileNameWithoutExtension(path);</div><div class="line">    Material material = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (atlasAsset.dynamicMats) <span class="comment">// 动态创建材质</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">foreach</span> (Material other <span class="keyword">in</span> atlasAsset.materials) &#123;</div><div class="line">            <span class="keyword">if</span> (other.name.Split(<span class="string">'_'</span>)[<span class="number">1</span>] == name) &#123; <span class="comment">// 这里要改一下,因为没有默认纹理了,需要用材质本身的名字来匹配</span></div><div class="line">                material = other;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</div><div class="line">            Debug.LogError(<span class="string">"Material with texture name \""</span> + name + <span class="string">"\" not found for atlas asset: "</span> + atlasAsset.name, atlasAsset);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        page.rendererObject = <span class="keyword">new</span> Material(material); <span class="comment">// 新建材质</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">foreach</span> (Material other <span class="keyword">in</span> atlasAsset.materials) &#123;</div><div class="line">            <span class="keyword">if</span> (other.mainTexture == <span class="literal">null</span>) &#123;</div><div class="line">                Debug.LogError(<span class="string">"Material is missing texture: "</span> + other.name, other);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (other.mainTexture.name == name) &#123;</div><div class="line">                material = other;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</div><div class="line">            Debug.LogError(<span class="string">"Material with texture name \""</span> + name + <span class="string">"\" not found for atlas asset: "</span> + atlasAsset.name, atlasAsset);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        page.rendererObject = material;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Very old atlas files expected the texture's actual size to be used at runtime.</span></div><div class="line">    <span class="keyword">if</span> (page.width == <span class="number">0</span> || page.height == <span class="number">0</span>) &#123;</div><div class="line">        page.width = material.mainTexture.width;</div><div class="line">        page.height = material.mainTexture.height;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为考虑到载入图集的频率不会很频繁,所以呢,我把Atlas上的rendererobject用这种方式提供了出来.<br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1pgvgczj20kb02gdg0.jpg" alt="img"> <br></p>
<p>然后就可以用这种方式在运行时修改纹理了.<br><br>Ps: 记得调用完后用 Resource.UnloadUnUsedAsset()来卸载内存. <br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1trfe7ij20bw01vjrh.jpg" alt="img"> <br></p>
<p>然后内存占用就会从这样 <br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1wtv9mrj20da03e3yi.jpg" alt="img"> <br><br>变成这样了. <br><br><img src="https://ws1.sinaimg.cn/large/44d3b0fbgy1fjr1ydn35cj20di04aaa7.jpg" alt="img"> <br><br>此例子中我只使用到了body图集,技能特效就全部不加载了,你可以用上面的方式,在需要的时候把图集载入进来关联到相应的材质上.<br></p>
<p>谢谢观赏!!!</p>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2017 <a href="/" rel="nofollow">John Doe</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>